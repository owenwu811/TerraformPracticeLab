Fequently missed Q's / unsure questions - 
5/15/2023
which directory are terraform plugins located?
.terraform/plugins

To find the ID attribute for a resource, run terraform show without arguments as terraform show shows all the details of each resource

Use a private key created in this resource in another resource of type local_file. Update key.tf with the requirements: resource name: key_details filename: /root/key.txt content: 
use a reference expression to use the attribute called private_key_pem of the pvtkey resource. 

Solution:

resource "tls_private_key" "pvtkey" {
  algorithm = "RSA"
  rsa_bits = 4096
}

resource "local_file" "key_details" {cr
  content = tls_private_key.pvtkey.private_key_pem
  filename = "/root/key.txt"
 }

Now, let's update this resource and add variables instead. Use the default value declared in the variable called jedi. the variable is a map. For argument called content, use the value of the key by the same name. and, similarly, for the argument called filename, use the value by the same name.

Solution:
resource "local_file" "jedi" {
  filename = var.jedi["filename"]
  content = var.jedi["content"]
 }
 
Resource A has a dependence on resource B but dosen’t access any of its attributes inside of its arguments:

Explicit dependency

Explanation:

Dosen’t access means that depends_on was used because you still know that there is a dependency, but it's just not accsessed inside of A's arguments, so it has to be explicity stated with a depends_on metaargument. 

-var takes the highest precedence in terraform variable definition precedence while enviornment variables take the lowest precedence.


The time static resource does not take any arguments to work. This is because it is used to generate a static timestamp that can be used as a value in other parts of the terraform configuration.
Time static resource does not create or manage any infrastructure resources.

Where is the terraform state file stored by default:

Inside of the configuration directory

To find the private ip for an address, run terraform show. an argument value is not necessary.

Terraform apply will show all the output values automatically without running terraform output.

reference expressions must have ${} if used with subsitution, similar to python formatted strings.

Create before destroy meta argument needs to be wrapped in a lifecycle block:

resource "random_string" "string" {
  length = var.length
  keepers = { length = var.length }
  lifecycle {
    create_before_destroy = true
   }
}

set(string) is a valid datatype in Terraform

Value of output variable pet-name?

terraform output pet-name

In terraform, if you use the count meta argument, elements are created as a list. This is because lists can be accessed using indexes, and count creates a fixed number of elements.

== is not a valid version constraint operator

What is the AWS command used to list all users? 

aws --endpoint http://aws:4566 iam list-users

Create a user named mary?

aws --endpoint http://aws:4566 iam create-user --user-name mary


What is the default region that has been configured for use with the AWS CLI?

cat /root/.aws/config | a more intuitive way would be "aws configure get region" command.

What is the access key id used in the configuration?

aws configure get aws_access_key_id

Now that we have a few users created, let's grant them privileges.
Let's start with mary, grant her full administrator access by making use of the policy called AdministratorAccess.
Make use of the subcommand attach-user-policy.
The ARN of the AdministratorAccess policy is arn:aws:iam::aws:policy/AdministratorAccess.

aws iam attach-user-policy --user-name mary --policy-arn arn:aws:iam::aws:policy/AdministratorAccess --endpoint http://aws:4566 (do not forget the endpoint)

jack and jill are developers and are part of a project called project-sapphire.
Create a new IAM Group called project-sapphire-developers.
Use the subcommand create-group to create the group.

aws iam create-group --group-name project-sapphire-developers --endpoint http://aws:4566 (Use aws iam help to find subcommands, and then read the synposis)



Add the IAM users called jack and jill, who are developers to the new IAM Group called project-sapphire-developers.
Use the subcommand add-user-to-group to add users into the group.

1. aws iam add-user-to-group help
2. read synposis + copy it somewhere
 Solution: aws iam add-user-to-group --group-name project-sapphire-developers --user-name jack  --endpoint http://aws:4566 
 
 aws iam add-user-to-group --group-name project-sapphire-developers --user-name jill  --endpoint http://aws:4566 
 
 
What privileges are granted for jack and jill who are part of the group project-sapphire-developers?

Check for their permissions individually and the ones granted to the group.

aws iam list-attached-group-policies --group-name project-sapphire-developers --endpoint http://aws:4566 (use aws iam help to find the list-attached-group-policies subcommand)

aws iam list-user-policies --user-name jill --endpoint http://aws:4566  (change the name to jack to see permissions jack has. Again, aws iam help to find list-user-policies subcommand, and then aws iam list-user-policies help to find the synposis to get required arguments)


Both jack and jill need complete access to the EC2 service.
Attach the AmazonEC2FullAccess policy with the ARN: arn:aws:iam::aws:policy/AmazonEC2FullAccess to the group project-sapphire-developers.

aws iam attach-group-policy --group-name project-sapphire-developers --policy-arn arn:aws:iam::aws:policy/AmazonEC2FullAccess --endpoint http://aws:4566


what does this error message mean: 
configuring Terraform AWS Provider: validating provider credentials: retrieving caller identity from STS: operation error STS: GetCallerIdentity, failed to resolve service endpoint, an AWS region is required, but was not found

Solution: the region is not set (aws region was required but not found)

Add a new file called provider.tf containing a provider block for aws. 
Inside this block add a single argument called region with the value ca-central-1
You don't have to run a terraform plan or apply at this stage.

solution: (provider needs a name)

provider "aws" {
  region = "ca-central-1"
}

--endpoint http://aws:4566 needs to be specified if we want to use a non default endpoint for that region

Now, update the iam-user.tf to make use of the count meta-argument to loop through the project-sapphire-users variable and create all the users in the list.
You may want to make use of the length function to get the length of the list.

resource "aws_iam_user" "users" {
     name = var.project-sapphire-users[count.index]
     count = length(var.project-sapphire-users)
}

- if terraform show displays resource blocks, then that means a resource has alrady been provisioned within the control of Terraform
- Bucket domain name is the same as DNS name for S3 Bucket

The main.tf file is empty. Use it to create a new S3 with the following specifications:
resource name: dc_bucket
bucket name: dc_is_better_than_marvel
Once the resource block is complete, run a terraform init, plan and apply to try and create the bucket.
If unsure, refer to the documentation. The documentation tab is available at the top right panel. 

Solution: (note that S3 bucket names in AWS must be unique. Also, this bucket name is not valid because it does not conform to DNS standards as it has underscores, so change it to dashes instead)

resource "aws_s3_bucket" "marvel-cinematic-universe" {
  bucket = "mcu-202011121359"

}
resource "aws_s3_bucket" "dc_bucket" {
        bucket = "dc-is-better-than-marvel"
}
Let's do that now and upload this image to the s3 bucket! Update the main.tf file with the following specifications:
Bucket: pixar-studios-2020
Key: woody.jpg
Source: /root/woody.jpg
Once ready, proceed to run terraform init, plan and apply.

(use aws_s3_bucket_object resource instead of aws_s3_bucket since it does not support key and source arguments per documentation. Note that s3 bucket name is an argument while resource name is not; they are different.)

Solution: (The resource name can be anything, but Bucket: is an argument value, not the resource name)

resource "aws_s3_bucket_object" "mine" {
        key = "woody.jpg"
        bucket = "pixar-studios-2020"
        source = "/root/woody.jpg"
}



Name of the table resource means resource name, not the value of the name argument in the resource:

resource "aws_dynamo_db_table" "project_sapphire_inventory" {
   name = "inventory"
   billing_mode = "PAY_PER_REQUEST"
   hash_key = "AssetID"
 }
 
 Name of the table resource would be "project_sapphire_inventory", not "inventory"
 
 
 
 Let's add an item to this table called inventory. Use the following specifications and update the main.tf file:
 Resource Name: Upload
 Table: Use the reference expression to the table called inventory
 Hash Key: Use reference expression to use the primary key used by the table inventory 
 Use the below data for the item:
 {
 AssetID: {"N": "1"},
 AssetName: {"S": "printer"},
 Age: {"N": "5"},
 Hardware: {"B": "true"}
 }
 
Mistake: we use aws_dynamo_db_table_item resource, not aws_dynamo_db_table because we are adding an item to the dynamodb table




terraform.tfvars is used to assign variable values while variables.tf is used to declare that a variable exists with a variable block




When there is no terraform.tfstate file, it usually means that terraform apply has not been run yet, but do check all the other answer choices to make sure no syntax errors and that the other answer choices don’t make sense before picking this choice.




If you haven't run terraform apply and try to run terraform show, it will show no state.

Incorrect:

resource "aws_dynamodb_table" "project_sapphire_user_data" {
  name           = "userdata"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "UserId"

  attribute {
    name = "Name"
    type = "S"
  }
}


Correct: (notice how type is N, and name is the value of hash_key argument)

resource "aws_dynamodb_table" "project_sapphire_user_data" {
  name           = "userdata"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "UserId"

  attribute {
    name = "UserId"
    type = "N"
  }
}

Terraform init is a command that can be run as many times as you want without any adverse effects.


Terraform state commands are used to edit the state file instead of manually editing the state file, because, when terraform state commands edit a resource, 
that resource is mediated and controlled and tracked by terraform, which prevents broken infrastructure.


Other common mistakes to remember:

- Just because you mkdir dosen’t mean you are automatically in that directory you just mkdired. You still have to cd to get into that directory.




 
 
